---
title: 小议 C++ STL 第二级配置器
date: 2019-10-02 01:40:14
tags:
---

我们知道，OS 分配内存是需要一定开销的，因此 stl 在实现 `allocator` 时采取了这样的方式：

- 对于大于 `128bytes` 的内存块，直接使用 `malloc` 和 `free` 来进行管理
- 对于小于等于 `128bytes` 的内存块，首先为了减小情况的复杂性，将内存块大小向上对齐到 `8bytes`，然后维护 $16$ 个链表，每次申请一定的（较大）空间，然后 stl 自己用内存池及链表等进行管理

但是，stl 自己进行内存管理当然也会产生一定的开销，如果这开销大于直接系统调用产生的开销，那么就得不偿失了。stl 对链表部分采取了一定的优化，其链表直接建立在待分配的内存中，而不再用额外的内存维护一个链表。具体地说，它将每一个内存块的头 `8bytes`（或者 `4bytes`，取决于指针的位数）作为指向下一个内存块的指针，当然最后一个内存块除外。当内存块分配给用户时，stl 不再需要管理这块内存，那么整个内存块，包括头 `8bytes`，自然就可以由用户自由使用了。

而在实现中，stl 采用的链表结点是这样的：

{% codeblock [lang:c++] %}
union _Obj{
    union _Obj* _M_free_list_link;
    char        _M_client_data[1];    // The client sees this.
};
{% endcodeblock %}

可以看出，stl 中额外增加了一个 `_M_client_data` 域，并使用 `union` 压缩空间。但是整个 stl 都没有用到这个域，从之前的算法描述来看，单个指针也足以实现该功能。对此我找到了两个帖子，相对比较有说服力：

- {% link 浅析STL空间配置器 https://my.oschina.net/u/3281747/blog/875605 %}
- {% link STL空间配置器的union obj https://blog.csdn.net/w450468524/article/details/51649222 %}
